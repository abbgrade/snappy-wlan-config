package config

import (
	"fmt"
	"github.com/deckarep/golang-set"
	"github.com/funkygao/golib/observer"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"path"
)

var (
	dryRun = false
)

func EnableDryRun() {
	dryRun = true
}

type Controller struct {
	Model             Config
	InterfacesDirPath string `yaml:"-"`
	ConfigPath        string `yaml:"-"`
}

func (config *Controller) Save() {

	// dump the YAML
	data, err := yaml.Marshal(&config)
	if err != nil {
		Warning.Fatalf("dump: %v", err)
	}

	// write the file
	if err := ioutil.WriteFile(config.ConfigPath, data, 0644); err != nil {
		Warning.Fatalf("write %v : %v", config.ConfigPath, err)
	}
}

func (config *Controller) Load() {

	// does the file exist?
	if _, err := os.Stat(config.ConfigPath); os.IsNotExist(err) {
		return
	}

	// read the file
	data, err := ioutil.ReadFile(config.ConfigPath)
	if err != nil {
		Warning.Fatalf("load: %v", err)
	}

	Trace.Printf("loaded %v", string(data))

	// parse the YAML
	if err := yaml.Unmarshal([]byte(data), &config); err != nil {
		Warning.Fatalf("parse: %v", err)
	}

}

func (config *Controller) Merge(request Transaction) {

	// configure observer
	observation := make(chan interface{})
	observationActive := true
	observer.Subscribe(EVENT_DELETE_INTERFACE, observation)

	// event handler
	go func() {
		for observationActive == true {
			interfaceName := <-observation
			if interfaceName == nil {
				continue
			}

			Trace.Printf("deleted interface: %#v\n", interfaceName)
			config.DeleteInterface(interfaceName.(string))
		}
	}()

	// act
	config.Model.Merge(request.Config.Model)

	// clean up observer
	observer.UnSubscribe(EVENT_DELETE_INTERFACE, observation)
	observationActive = false

}

func (config *Controller) GetWifiConfigPath(interfaceName string) string {

	fileName := fmt.Sprintf("interface_%v.conf", interfaceName)
	return path.Join(config.InterfacesDirPath, fileName)

}

func (config *Controller) GetAccesspointConfigPath() string {
	return "/etc/hostapd/hostapd.conf"
}

func (config *Controller) GetNetworkConfigPath(interfaceName string) string {

	return fmt.Sprintf("/etc/network/interfaces.d/%v", interfaceName)

}

type ExportFile struct {
	path string
	file *os.File
}

func NewExportFile(path string) ExportFile {

	export := ExportFile{}

	export.path = path

	Trace.Printf("export: %v", path)
	if dryRun == true {
		export.file = os.Stdout
	} else if file, err := os.Create(path); err != nil {
		Warning.Fatalf("export %v : %v", path, err)
	} else {
		export.file = file
		defer export.file.Close()
	}

	return export
}

func (export *ExportFile) AddHeader(toolName string) {
	fmt.Fprint(export.file, "# DO NOT CHANGE THIS FILE\n")
	fmt.Fprintf(export.file, "# This %v config file is generated by snappy-wlan-config,\n", toolName)
	fmt.Fprint(export.file, "# manual changes may become reversed.\n")
	fmt.Fprint(export.file, "\n")
}

func (config *Controller) ExportWifiClient(interfaceName string, networks []WifiConfig) {
	path := config.GetWifiConfigPath(interfaceName)
	export := NewExportFile(path)

	// add a file header
	export.AddHeader("wpasupplicant")

	for _, network := range networks {

		if network.GetConnectionType() != CONNECTION_TYPE_CLIENT {
			continue
		}

		// add each network configuration
		networkExport := NewWifiExport(&network)
		fmt.Fprintf(export.file, "%v, \n", networkExport.Dump())
		export.file.Sync()
	}
}

func (config *Controller) ExportWifiAccesspoint(networks []WifiConfig) {
	path := config.GetAccesspointConfigPath()
	export := NewExportFile(path)

	for _, network := range networks {

		if network.GetConnectionType() == CONNECTION_TYPE_CLIENT {
			continue
		}

		// There can be only one accesspoint so overwrite the existing content
		export.file.Seek(0, 0)

		// add a file header
		export.AddHeader("hostapd")

		// add each network configuration
		exportAccesspoint := NewAccesspointExport(&network)
		fmt.Fprintf(export.file, "%v\n", exportAccesspoint.Dump())
		export.file.Sync()
	}
}

func (config *Controller) ExportInterface(interfaceName string, networks []WifiConfig) {
	path := config.GetNetworkConfigPath(interfaceName)
	export := NewExportFile(path)

	// export unique networks
	networkExports := mapset.NewSet()
	for _, network := range networks {

		networkExport := NewNetworkExport(&network)
		networkExports.Add(networkExport.Dump())

	}

	// add a file header
	export.AddHeader("interfaces")

	// add each  export
	for network := range networkExports.Iter() {

		fmt.Fprintf(export.file, "%v\n", network.(string))
		export.file.Sync()

	}
}

func (config *Controller) Export() {

	// sort networks by the interface
	interfaces := make(map[string][]WifiConfig)

	for _, network := range config.Model.Networks {

		// set default interface
		network.Interface = StringCoalesce(network.Interface, INTERFACE_DEFAULT)

		// add network to the networks of the same interface
		interfaces[network.Interface] = append(interfaces[network.Interface], network)
	}

	for interfaceName, networks := range interfaces {

		// create a config file for each wifi interface
		config.ExportWifiClient(interfaceName, networks)

		// create a config file for accesspoints
		config.ExportWifiAccesspoint(networks)

		// create a config file for each interface
		config.ExportInterface(interfaceName, networks)

	}
}

func (config *Controller) DeleteInterface(interfaceName string) {

	interfacePath := config.GetWifiConfigPath(interfaceName)
	if err := os.Remove(interfacePath); err != nil {
		Warning.Fatalf("delete %v : %v", interfacePath, err)
	}
	Info.Printf("deleted: %v\n", interfacePath)

}
